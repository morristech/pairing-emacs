* Internetting

  For those that like the UI emacs provides (or perhaps just enjoy the
  uniformity of using the same UI for programming and for everything
  else), emacs can be used to read email, and do various other
  internettey things.

  Right now, the main thing I've set up is loading github keys from
  lastpass. You can do this with ~M-x gds-load-github-keys~. You can
  read about [[*SSH Keys][how it works, and the prerequisites below]].

** Lexical Binding
   A lot of the elisp in this file requires lexical binding. We should
   enable it up front, before getting into the meat of things.
   #+BEGIN_SRC emacs-lisp
     ;;; -*- lexical-binding: t -*-
   #+END_SRC

** SSH Keys
   A lot of the things I work on are stored in github repos. While
   emacs can manage local clones of those repos out-of-the-box, if I
   want to be able to push, I'll need to load my creds.

   To make this possible, I've already stored a private SSH key (with
   a sensible passphrase) as a lastpass note in the location
   =Personal/github-ssh-key=.

   This also makes use of our [[*Lastpass][lastpass functions]], and hence requires
   that you already have the [[https://github.com/lastpass/lastpass-cli][lpass CLI]] installed.

   To load your keys until 6pm (which, for me, is the end of the
   working day), do =M-x gds-load-github-keys=. If it's after 6pm, or
   you just want to load keys for a different amount of time, do =M-x
   gds-load-github-keys-for= and enter the number of hours of access
   you want when prompted.

   #+BEGIN_SRC emacs-lisp
     (defun gds-load-github-keys-for-seconds (seconds)
       "Load my github keys from lastpass for SECONDS seconds.

     Ensure I'm logged in to lastpass. Then load my github keys from
     Personal/github-ssh-key for one SECONDS seconds."

       (gds-lastpass-ensure-logged-in-and-then
	(lambda ()

	  (let ((keyfile (make-temp-file "gdskeyfile")))

	    (with-temp-file keyfile)
	    (set-file-modes keyfile #o0600)
	    (with-temp-file keyfile
	      (insert (gds-lastpass-get-note "Personal/github-ssh-key")))

	    (when (get-process "ssh-add-github") ; Kill any previous stalled ssh-add attempt
	      (delete-process "ssh-add-github"))

	    (let ((process (start-process-shell-command
			    "ssh-add-github"
			    nil
			    (format "ssh-add -t %d %s" seconds keyfile))))

	      (set-process-filter
	       process
	       (lambda (proc string)
		 (when (string-match-p (regexp-quote "Enter passphrase for") string)
		   (process-send-string proc
					(concat (read-passwd "Key passphrase? ") "\n")))
		 (when (string-match-p (regexp-quote "Identity added") string)
		   (delete-file keyfile)
		   (message "SSH Key successfully loaded")))))))))

     (defun gds-load-github-keys-for (hours)
	 "Load my github keys from lastpass for HOURS hours.

     Use `gds-load-github-keys-for-seconds' to load keys from
     lastpass"
	   (interactive "nHow long for? ")
	   (gds-load-github-keys-for-seconds (* 3600 hours)))

     (defun gds-load-github-keys ()
       "Load my github keys from lastpass until 6pm.

     Calculate how long it'll be until 6pm, then use
     `gds-load-github-keys-for-seconds' to load my keys until then."
       (interactive)

       (let* ((now (current-time))
	      (now-decoded (decode-time now))
	      (eod (encode-time (list
				 0			;Seconds
				 0			;Minutes
				 18			;Hours
				 (nth 3 now-decoded)	;Day
				 (nth 4 now-decoded)	;Month
				 (nth 5 now-decoded)	;Year
				 (nth 6 now-decoded)	;DOW -- Ignored by encode but whatevs.
				 (nth 7 now-decoded)	;DST
				 (nth 8 now-decoded)	;Zone (UTC offset)
				 ))))
	 (if (time-less-p eod now)
	     (error "Looks like 6pm has been and gone")
	   (let ((timeleft (time-subtract eod now)))
	     (gds-load-github-keys-for-seconds (time-to-seconds timeleft))))))
   #+END_SRC

** Lastpass

   Of course in order to do anything on the internet, we'll need
   credentials. And storing those in a config file in git would be
   unwise. Let's keep them in lastpass!

   Unhappily, as I write this, the [[https://melpa.org/#/lastpass][lastpass module on melpa]] hasn't
   been updated in over a year, and doesn't seem to work with the
   latest CLI. So we'll have to roll our own for the tiny things we
   want.

   The bare minimum is to be able to log in and out. Let's assume that
   the =lpass= CLI is in the ~$PATH~.

   #+BEGIN_SRC emacs-lisp
     (defun gds-lastpass-ensure-logged-in-and-then (continuation)
       "Ensure the lpass CLI is logged in, then call CONTINUATION.

     Check with `lpass status` if we're logged in. If not, log
     in. Once we're logged in, call CONTINUATION."

       (let ((lpass-status (shell-command-to-string "lpass status --color=never"))) 

	 (when (string-match-p (regexp-quote "Logged in as") lpass-status)
	   (message "Lastpass was already logged in")
	   (funcall continuation))

	 (when (string-match-p (regexp-quote "Not logged in.") lpass-status)

	   (when (get-process "lastpass")	; Kill any previous stalled login attempt
	     (delete-process "lastpass"))

	   ;; Start trying to log in
	   (let* ((username (read-string "Who should we log in to lastpass as? "))
		  (process (start-process-shell-command 
			    "lastpass"
			    nil
			    (concat "LPASS_DISABLE_PINENTRY=1 lpass login "
				    (shell-quote-argument username)))))
	     (set-process-filter
	      process
	      ;; Respond to password and 2fa challenges
	      (lambda (proc string)
		(when (string-match-p (regexp-quote "Master Password") string)
		  (process-send-string proc
				       (concat (read-passwd "Lastpass Master Password? ") "\n")))
		(when (string-match-p (regexp-quote "Code") string)
		  (unless (string-match-p (regexp-quote "out-of-band") string)
		    (process-send-string proc
					 (concat (read-passwd "2FA Code? ") "\n"))))
		(when (string-match-p (regexp-quote "Success") string)
		  (message "Lastpass logged in")
		  (funcall continuation)))))))) ; This needs lexical binding

     (defun gds-lastpass-login ()
       "Ensure the lpass CLI is logged in.

     Check with `lpass status` if we're logged in. If not, log in."
       (interactive)
       (gds-lastpass-ensure-logged-in-and-then (lambda ())))

     (defun gds-lastpass-logout ()
       "Ensure the lpass CLI is logged out."
       (interactive)

       (shell-command "lpass logout -f")
       (message "Lastpass logged out"))

     (defun gds-lastpass-get-note (note-path)
       "Get a secure note from lastpass.

     We must already be logged in to lastpass for this to work. Use
     `gds-lastpass-ensure-logged-in-and-then' to be sure."
       (shell-command-to-string
	(format "lpass show %s --notes" note-path)))
   #+END_SRC

** Slack

   If you want to use [[https://slack.com][slack]] in emacs, this will do the trick. The code
   below downloads and configures the [[https://github.com/yuya373/emacs-slack][slack package]] by Yuya Minami. In
   order for this configuration to work, we need credentials. And of
   course, all credentials should be stored in lastpass.

   Create a lastpass Note at location =Personal/slack-creds=, and put
   the following JSON in there:

   #+BEGIN_SRC json
   [{ "name": "my-slack-workspace",
   "id": "aaaaaaaaaaa.00000000000",
   "secret": "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
   "token": "xoxs-sssssssssss-88888888888-hhhhhhhhhhh-jjjjjjjjjj"}]
   #+END_SRC

   ...and edit that json to connect to the slack workspace you're
   interested in, and to use your own ID, secret, and
   token. Unfortunately you can't use use OAuth or give it your
   regular password, so getting those credentials is a little
   involved. [[https://github.com/yuya373/emacs-slack#how-to-get-token-the-easy-way][Read how here]].

   Once your creds are in lastpass, you can configure and start
   emacs-slack with =M-x gds-slack-configure-and-start=, and the rest
   should [[https://github.com/yuya373/emacs-slack/wiki/ScreenShots][work as advertised]].

   #+BEGIN_SRC emacs-lisp
     (use-package slack
       :ensure t
       :commands (slack-start)
       :init
       (setq slack-buffer-emojify t)
       (setq slack-prefer-current-team t))

     (defun gds-slack-configure-and-start ()
       "Configure slack from lastpass, and start it.

     Assuming you have your slack creds in JSON format in lastpass,
       this function will use those creds to configure your slack, and
       will start it for you."
       (interactive)
       (gds-lastpass-ensure-logged-in-and-then
	(lambda ()
	  (let* ((creds (json-read-from-string (gds-lastpass-get-note "Personal/slack-creds"))))
	    (map-do
	     (lambda (n team)
	       (slack-register-team
		:name (alist-get 'name team)
		:default t
		:client-id (alist-get 'id team)
		:client-secret (alist-get 'secret team)
		:token (alist-get 'token team)
		:subscribed-channels '()
		:full-and-display-names t))
	     creds))
	  (slack-start))))
   #+END_SRC

*** TODO Should I add a subscribed channel list to lastpass?
    I think this would mean we get alerts for non-mentions in all
    channels in that list. I think the default is to get an alert for
    mentions, and for "open channels".

    It's probably also worth checking out this [[http://endlessparentheses.com/keep-your-slack-distractions-under-control-with-emacs.html][keeping distractions
    under control]] blog before making decisions here.

** Email

   I've historically liked [[http://gnus.org/][gnus]] for email, news, and RSS.

*** TODO See if gnus makes sense with my current gmail setup

*** TODO See if gnus can play nice with my lastpass setup
