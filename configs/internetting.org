* Internetting

  For those that like the UI emacs provides (or perhaps just enjoy the
  uniformity of using the same UI for programming and for everything
  else), emacs can be used to chat on slack, read email, and do
  various other internettey things.

  Here are some of them:
  - [[*SSH Keys][SSH Keys]]
    - I keep my github ssh keys in lastpass, and access them with ~M-x
      gds-load-github-keys~.
  - [[*Slack][Slack]]
  - [[*Email][Email]]

  For details on how those things work, and what lastpass entries you
  need to create in order to make them work for you, see below.

**** Prerequisites
     A lot of the elisp in this file requires lexical binding. We should
     enable it up front, before getting into the meat of things.
     #+BEGIN_SRC emacs-lisp
       ;;; -*- lexical-binding: t -*-
     #+END_SRC

** SSH Keys
   A lot of the things I work on are stored in github repos. While
   emacs can manage local clones of those repos out-of-the-box, if I
   want to be able to push, I'll need to load my creds.

   To make this possible, I've already stored a private SSH key (with
   a sensible passphrase) as a lastpass note in the location
   =Personal/github-ssh-key=.

   This also makes use of our [[*Lastpass][lastpass functions]], and hence requires
   that you already have the [[https://github.com/lastpass/lastpass-cli][lpass CLI]] installed.

   To load your keys until 6pm (which, for me, is the end of the
   working day), do =M-x gds-load-github-keys=. If it's after 6pm, or
   you just want to load keys for a different amount of time, do =M-x
   gds-load-github-keys-for= and enter the number of hours of access
   you want when prompted.

   #+BEGIN_SRC emacs-lisp
     (defun gds-load-github-keys-for-seconds (seconds)
       "Load my github keys from lastpass for SECONDS seconds.

     Ensure I'm logged in to lastpass. Then load my github keys from
     Personal/github-ssh-key for one SECONDS seconds."

       (gds-lastpass-ensure-logged-in-and-then
	(lambda ()

	  (let ((keyfile (make-temp-file "gdskeyfile")))

	    (with-temp-file keyfile)
	    (set-file-modes keyfile #o0600)
	    (with-temp-file keyfile
	      (insert (gds-lastpass-get-note "Personal/github-ssh-key")))

	    (when (get-process "ssh-add-github") ; Kill any previous stalled ssh-add attempt
	      (delete-process "ssh-add-github"))

	    (let ((process (start-process-shell-command
			    "ssh-add-github"
			    nil
			    (format "ssh-add -t %d %s" seconds keyfile))))

	      (set-process-filter
	       process
	       (lambda (proc string)
		 (when (string-match-p (regexp-quote "Enter passphrase for") string)
		   (process-send-string proc
					(concat (read-passwd "Key passphrase? ") "\n")))
		 (when (string-match-p (regexp-quote "Identity added") string)
		   (delete-file keyfile)
		   (message "SSH Key successfully loaded")))))))))

     (defun gds-load-github-keys-for (hours)
	 "Load my github keys from lastpass for HOURS hours.

     Use `gds-load-github-keys-for-seconds' to load keys from
     lastpass"
	   (interactive "nHow long for? ")
	   (gds-load-github-keys-for-seconds (* 3600 hours)))

     (defun gds-load-github-keys ()
       "Load my github keys from lastpass until 6pm.

     Calculate how long it'll be until 6pm, then use
     `gds-load-github-keys-for-seconds' to load my keys until then."
       (interactive)

       (let* ((now (current-time))
	      (now-decoded (decode-time now))
	      (eod (encode-time (list
				 0			;Seconds
				 0			;Minutes
				 18			;Hours
				 (nth 3 now-decoded)	;Day
				 (nth 4 now-decoded)	;Month
				 (nth 5 now-decoded)	;Year
				 (nth 6 now-decoded)	;DOW -- Ignored by encode but whatevs.
				 (nth 7 now-decoded)	;DST
				 (nth 8 now-decoded)	;Zone (UTC offset)
				 ))))
	 (if (time-less-p eod now)
	     (error "Looks like 6pm has been and gone")
	   (let ((timeleft (time-subtract eod now)))
	     (gds-load-github-keys-for-seconds (time-to-seconds timeleft))))))
   #+END_SRC

** Slack

   If you want to use [[https://slack.com][slack]] in emacs, this will do the trick. The code
   below downloads and configures the [[https://github.com/yuya373/emacs-slack][slack package]] by Yuya Minami. In
   order for this configuration to work, we need credentials. And of
   course, all credentials should be stored in lastpass.

   Create a lastpass =Note= at location =Personal/slack-creds=, and put
   the following JSON in there:

   #+BEGIN_SRC json
   [{ "name": "my-slack-workspace",
   "id": "aaaaaaaaaaa.00000000000",
   "secret": "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
   "token": "xoxs-sssssssssss-88888888888-hhhhhhhhhhh-jjjjjjjjjj"}]
   #+END_SRC

   Edit that json to connect to the slack workspace you're
   interested in, and to use your own ID, secret, and
   token. Unfortunately you can't use use OAuth or give it your
   regular password, so getting those credentials is a little
   involved. [[https://github.com/yuya373/emacs-slack#how-to-get-token-the-easy-way][Read how here]].

   You might notice that the JSON you just created is a list of
   objects. If you want to configure multiple slack workspaces, create
   one object per workspace, and add them to your list.

   Once your creds are in lastpass, you can configure and start
   emacs-slack with =M-x gds-slack-configure-and-start=, and the rest
   should [[https://github.com/yuya373/emacs-slack/wiki/ScreenShots][work as advertised]].

   #+BEGIN_SRC emacs-lisp
     (use-package slack
       :ensure t
       :commands (slack-start)
       :init
       (setq slack-buffer-emojify t)
       (setq slack-prefer-current-team t))

     (defun gds-slack-configure-and-start ()
       "Configure slack from lastpass, and start it.

     Assuming you have your slack creds in JSON format in lastpass,
       this function will use those creds to configure your slack, and
       will start it for you."
       (interactive)
       (gds-lastpass-ensure-logged-in-and-then
	(lambda ()
	  (let* ((creds (json-read-from-string (gds-lastpass-get-note "Personal/slack-creds"))))
	    (map-do
	     (lambda (n team)
	       (slack-register-team
		:name (alist-get 'name team)
		:default t
		:client-id (alist-get 'id team)
		:client-secret (alist-get 'secret team)
		:token (alist-get 'token team)
		:subscribed-channels '()
		:full-and-display-names t))
	     creds))
	  (slack-start))))
   #+END_SRC

*** TODO Should I add a subscribed channel list to lastpass?
    I think this would mean we get alerts for non-mentions in all
    channels in that list. I think the default is to get an alert for
    mentions, and for "open channels".

    It's probably also worth checking out this [[http://endlessparentheses.com/keep-your-slack-distractions-under-control-with-emacs.html][keeping distractions
    under control]] blog before making decisions here.

** Email

   If you don't know why you would want to read email in emacs then no
   worries -- it's a pretty weird thing to do.

   But if you keep getting frustrated at your email or webmail client
   because something that would be easy in your text editor is hard in
   an email, then maybe check out:
   - the [[https://www.emacswiki.org/emacs/CategoryMail][Mail Category in the emacs wiki]] for emacs solutions
   - The following minimal mail clients that work with any text editor:
     - [[http://www.mutt.org/][mutt]]
     - [[https://sup-heliotrope.github.io/][sup]]
     - [[https://notmuchmail.org/][notmuch]]

   If you like keeping your inbox empty (and probably using trello or
   org-mode as a todo list instead of using your inbox as a todo
   list), then this [[http://gnus.org/][gnus]] setup might work for you.

   Be warned, gnus is not a regular email client. It was originally a
   usenet news reader. When used to read email, I think it works best
   with a workflow in which every email is read at most once, and then
   either archived, deleted, or attached to some task so we can come
   back to it later.

*** How to use it
     To make this work, we'll need some
     credentials in lastpass. Create a lastpass =Note= at location
     =Personal/email-creds=, and put the following JSON there:

     #+BEGIN_SRC json
       {
	   "user-email-address": "me@where.ever.i.live",
	   "user-full-name": "My Name",
	   "email-provider-name": "Gmail or whatever",
	   "imap-address": "imap.gmail.com or similar",
	   "smtp-address": "smtp.gmail.com or similar",
	   "smtp-port": "587 or similar",
	   "username": "my-username",
	   "password": "my-password"
       }
     #+END_SRC

     If you're using gmail, you'll have to [[https://support.google.com/accounts/answer/185839?hl=en][enable 2 factor auth]], and
     [[https://support.google.com/accounts/answer/185833?hl=en][create an app specific password]]. This is the password that you'll
     need to put in your creds -- *not* your regular google password.

     Once your configuration is safely in lastpass, run =M-x
     gds-gnus-go= to read your mail.

     If this is your first time using gnus, [[https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org][there are]] some [[https://koldfront.dk/text/gnus-email-tutorial.html#letsgo][decent
     introductions]] on the web, and once you have the rough idea, the
     [[https://www.gnus.org/manual.html][gnus manual]] is very good.

*** Trade-offs
     We're going to use IMAP to talk to gmail, because I want the view
     of my email on my phone to be synced with the view of my email on
     my laptop.

     We're going to use an elisp implementation of imap so that this
     configuration is as portable as possible. Unfortunately, that
     also makes it *slow*. And since emacs is single-threaded, when
     you hit "get mail", it'll lock up emacs for maybe 15 seconds
     while it syncs.

     At some point, I might try to include an [[https://www.offlineimap.org/][offlineimap]] setup in
     here or something like that.

*** The actual configuration
     Most of the following configuration is borrowed straight from the
     [[https://www.emacswiki.org/emacs/GnusGmail][emacswiki page for making gmail work with gnus]]. The authinfo shim
     is heavily informed by [[https://github.com/DamienCassou/auth-password-store/blob/master/auth-source-pass.el][Daimian Cassou's auth-password-store]].

     #+BEGIN_SRC emacs-lisp
       (defun gds-gnus-go ()
	 "Configure gnus from lastpass, then run it.

       Use `gds-gnus-configure' to configure gnus using creds form
       lastpass. Then run gnus."
	 (interactive)
	 (gds-gnus-configure-and-then
	  (lambda ()
	    (gnus))))

       (defun gds-gnus-configure ()
	 "Pull email creds from lastpass and configure gnus with them."
	 (interactive)
	 (gds-gnus-configure-and-then (lambda ())))

       (defun gds-gnus-configure-and-then (continuation)
	 "Asynchronously configure gnus with creds from lastpass.

       Once we're done, call CONTINUATION."
	 (gds-lastpass-ensure-logged-in-and-then
	  (lambda ()
	    (let* ((creds (json-read-from-string (gds-lastpass-get-note "Personal/email-creds")))
		   (mail-address (alist-get 'user-email-address creds))
		   (full-name (alist-get 'user-full-name creds))
		   (email-provider-name (alist-get 'email-provider-name creds))
		   (imap-address (alist-get 'imap-address creds))
		   (smtp-address (alist-get 'smtp-address creds))
		   (smtp-port (alist-get 'smtp-port creds))
		   (username (alist-get 'username creds))
		   (password (alist-get 'password creds)))

	      ;; First configure gnus with non-secrets
	      (setq user-mail-address mail-address)
	      (setq user-full-name full-name)

	      (setq gnus-select-method
		    (list 'nnimap email-provider-name
			  (list 'nnimap-address imap-address)
			  '(nnimap-server-port "imaps")
			  '(nnimap-stream ssl)))

	      (setq smtpmail-smtp-server smtp-address
		    smtpmail-smtp-service smtp-port
		    gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

	      ;; Now shim our secrets into the auth-source framework, so we
	      ;; don't have to manually type in our app-specific password.
	      (cl-defun gds-gnus-auth-source-search (&rest spec
							   &key backend type host user port
							   &allow-other-keys)
		(let ((host-address (if (listp host)
					(cadr host)
				      host)))
		  (cond ((string= imap-address host-address)
			 ;; IMAP Gmail Creds
			 (list (list
				:host host-address
				:port "imaps"
				:user username
				:secret password)))
			((string= smtp-address host-address)
			 ;; SMTP Gmail Creds
			 (list (list
				:host host-address
				:port smtp-port
				:user username
				:secret password))))))

	      (defvar gds-gnus-auth-source-backend
		(auth-source-backend "gds-gnus"
				     :source "." ;; not used
				     :type 'gds-gnus
				     :search-function #'gds-gnus-auth-source-search)
		"Auth-source backend variable for gds-gnus shim.")

	      (add-to-list 'auth-sources 'gds-gnus)
	      (auth-source-forget-all-cached))

	    (defun gds-gnus-auth-source-backend-parse (entry)
	      "Create auth-source backend from ENTRY."
	      (when (eq entry 'gds-gnus)
		(auth-source-backend-parse-parameters entry gds-gnus-auth-source-backend)))

	    ;; Advice to add custom auth-source function
	    (if (boundp 'auth-source-backend-parser-functions)
		(add-hook 'auth-source-backend-parser-functions #'gds-gnus-auth-source-backend-parse)
	      (advice-add 'auth-source-backend-parse :before-until #'gds-gnus-auth-source-backend-parse))

	    (message "Gnus configured from lastpass")
	    (funcall continuation))))
     #+END_SRC

*** Open-in-gmail
    Sometimes it's useful to be able to open the message you're
    currently looking at in gmail. That way, you can create gmail
    filters based on it, and that kind of thing.

    #+BEGIN_SRC emacs-lisp
      (defun gds-gnus-open-in-gmail ()
	"Open the current article in gmail.

	Extract the message-id from the article header, then construct a
      gmail URL to find it."
	(interactive)
	(let* ((msg-header (gnus-summary-article-header))
	       (msg-id (mail-header-id msg-header))
	       (url-id (url-hexify-string (format "rfc822msgid:%s" msg-id)))
	       (message-url (format "https://mail.google.com/mail/u/0/?ibxr=0#search/%s" url-id)))
	  (browse-url message-url)))

      (define-minor-mode gds-gnus-summary-mode
	"Toggle gds-gnus-summary-mode

      Gds-gnus-summary-mode adds gds's extra keyboard shortcuts to
      gnus. Right now, that just means a function to open the current
      message in gmail will be bound to C-c g."
	:keymap (let ((map (make-sparse-keymap)))
		  (define-key map (kbd "C-c g") #'gds-gnus-open-in-gmail)
		  map))

      (add-hook 'gnus-summary-mode-hook #'gds-gnus-summary-mode)
    #+END_SRC
*** TODO Extract the auth-source shim business
    All that stuff is pretty ugly in-line, and would be testable as a
    library.

** Lastpass

   Of course in order to do anything on the internet, we'll need
   credentials. And storing those in a config file in git would be
   unwise. Let's keep them in lastpass!

   Unhappily, as I write this, the [[https://melpa.org/#/lastpass][lastpass module on melpa]] hasn't
   been updated in over a year, and doesn't seem to work with the
   latest CLI. So we'll have to roll our own for the tiny things we
   want.

   The bare minimum is to be able to log in and out. Let's assume that
   the =lpass= CLI is in the ~$PATH~.

   #+BEGIN_SRC emacs-lisp
     (defun gds-lastpass-ensure-logged-in-and-then (continuation)
       "Ensure the lpass CLI is logged in, then call CONTINUATION.

     Check with `lpass status` if we're logged in. If not, log
     in. Once we're logged in, call CONTINUATION."

       (let ((lpass-status (shell-command-to-string "lpass status --color=never"))) 

	 (when (string-match-p (regexp-quote "Logged in as") lpass-status)
	   (message "Lastpass was already logged in")
	   (funcall continuation))

	 (when (string-match-p (regexp-quote "Not logged in.") lpass-status)

	   (when (get-process "lastpass")	; Kill any previous stalled login attempt
	     (delete-process "lastpass"))

	   ;; Start trying to log in
	   (let* ((username (read-string "Who should we log in to lastpass as? "))
		  (process (start-process-shell-command 
			    "lastpass"
			    nil
			    (concat "LPASS_DISABLE_PINENTRY=1 lpass login "
				    (shell-quote-argument username)))))
	     (set-process-filter
	      process
	      ;; Respond to password and 2fa challenges
	      (lambda (proc string)
		(when (string-match-p (regexp-quote "Master Password") string)
		  (process-send-string proc
				       (concat (read-passwd "Lastpass Master Password? ") "\n")))
		(when (string-match-p (regexp-quote "Code") string)
		  (unless (string-match-p (regexp-quote "out-of-band") string)
		    (process-send-string proc
					 (concat (read-passwd "2FA Code? ") "\n"))))
		(when (string-match-p (regexp-quote "Success") string)
		  (message "Lastpass logged in")
		  (funcall continuation)))))))) ; This needs lexical binding

     (defun gds-lastpass-login ()
       "Ensure the lpass CLI is logged in.

     Check with `lpass status` if we're logged in. If not, log in."
       (interactive)
       (gds-lastpass-ensure-logged-in-and-then (lambda ())))

     (defun gds-lastpass-logout ()
       "Ensure the lpass CLI is logged out."
       (interactive)

       (shell-command "lpass logout -f")
       (message "Lastpass logged out"))

     (defun gds-lastpass-get-note (note-path)
       "Get a secure note from lastpass.

     We must already be logged in to lastpass for this to work. Use
     `gds-lastpass-ensure-logged-in-and-then' to be sure."
       (shell-command-to-string
	(format "lpass show %s --notes" note-path)))
   #+END_SRC
