* Internetting

  For those that like the UI emacs provides (or perhaps just enjoy the
  uniformity of using the same UI for programming and for everything
  else), emacs can be used to read email, and do various other
  internettey things.

  Right now, the main thing I've set up is loading github keys from
  lastpass. You can do this with ~M-x gds-load-github-keys~. You can
  read about [[*SSH Keys][how it works, and the prerequisites below]].

** SSH Keys
   A lot of the things I work on are stored in github repos. While
   emacs can manage local clones of those repos out-of-the-box, if I
   want to be able to push, I'll need to load my creds.

   To make this possible, I've already stored a private SSH key (with
   a sensible passphrase) as a lastpass note in the location
   =Personal/github-ssh-key=.

   This also makes use of our [[*Lastpass][lastpass functions]], and hence requires
   that you already have the [[https://github.com/lastpass/lastpass-cli][=lpass= CLI]] installed.

   To load your keys until 6pm (which, for me, is the end of the
   working day), do =M-x gds-load-github-keys=. If it's after 6pm, or
   you just want to load keys for a different amount of time, do =M-x
   gds-load-github-keys-for= and enter the number of hours of access
   you want when prompted.

   #+BEGIN_SRC emacs-lisp
     (defun gds-load-github-keys-for-seconds (seconds)
       "Load my github keys from lastpass for SECONDS seconds.

     Ensure I'm logged in to lastpass. Then load my github keys from
     Personal/github-ssh-key for one SECONDS seconds."

       (gds-lastpass-ensure-logged-in-and-then
	(lambda ()

	  (let ((keyfile (make-temp-file "gdskeyfile")))

	    (with-temp-file keyfile)
	    (set-file-modes keyfile #o0600)
	    (with-temp-file keyfile
	      (insert (shell-command-to-string
		       "lpass show Personal/github-ssh-key --notes")))

	    (when (get-process "ssh-add-github") ; Kill any previous stalled ssh-add attempt
	      (delete-process "ssh-add-github"))

	    (let ((process (start-process-shell-command
			    "ssh-add-github"
			    nil
			    (format "ssh-add -t %d %s" seconds keyfile))))

	      (set-process-filter
	       process
	       (lambda (proc string)
		 (when (string-match-p (regexp-quote "Enter passphrase for") string)
		   (process-send-string proc
					(concat (read-passwd "Key passphrase? ") "\n")))
		 (when (string-match-p (regexp-quote "Identity added") string)
		   (delete-file keyfile)
		   (message "SSH Key successfully loaded")))))))))

     (defun gds-load-github-keys-for (hours)
	 "Load my github keys from lastpass for HOURS hours.

     Use `gds-load-github-keys-for-seconds' to load keys from
     lastpass"
	   (interactive "nHow long for? ")
	   (gds-load-github-keys-for-seconds (* 3600 hours)))

     (defun gds-load-github-keys ()
       "Load my github keys from lastpass until 6pm.

     Calculate how long it'll be until 6pm, then use
     `gds-load-github-keys-for-seconds' to load my keys until then."
       (interactive)

       (let* ((now (current-time))
	      (now-decoded (decode-time now))
	      (eod (encode-time (list
				 0			;Seconds
				 0			;Minutes
				 18			;Hours
				 (nth 3 now-decoded)	;Day
				 (nth 4 now-decoded)	;Month
				 (nth 5 now-decoded)	;Year
				 (nth 6 now-decoded)	;DOW -- Ignored by encode but whatevs.
				 (nth 7 now-decoded)	;DST
				 (nth 8 now-decoded)	;Zone (UTC offset)
				 ))))
	 (if (time-less-p eod now)
	     (error "Looks like 6pm has been and gone")
	   (let ((timeleft (time-subtract eod now)))
	     (gds-load-github-keys-for-seconds (time-to-seconds timeleft))))))
   #+END_SRC

** Lastpass

   Of course in order to do anything on the internet, we'll need
   credentials. And storing those in a config file in git would be
   unwise. Let's keep them in lastpass!

   Unhappily, as I write this, the [[https://melpa.org/#/lastpass][lastpass module on melpa]] hasn't
   been updated in over a year, and doesn't seem to work with the
   latest CLI. So we'll have to roll our own for the tiny things we
   want.

   The bare minimum is to be able to log in and out. Let's assume that
   the =lpass= CLI is in the ~$PATH~.

   #+BEGIN_SRC emacs-lisp
     ;;; -*- lexical-binding: t -*-

     (defun gds-lastpass-ensure-logged-in-and-then (continuation)
       "Ensure the lpass CLI is logged in, then call CONTINUATION.

     Check with `lpass status` if we're logged in. If not, log
     in. Once we're logged in, call CONTINUATION."

       (let ((lpass-status (shell-command-to-string "lpass status --color=never"))) 

	 (when (string-match-p (regexp-quote "Logged in as") lpass-status)
	   (message "Lastpass was already logged in")
	   (funcall continuation))

	 (when (string-match-p (regexp-quote "Not logged in.") lpass-status)

	   (when (get-process "lastpass")	; Kill any previous stalled login attempt
	     (delete-process "lastpass"))

	   ;; Start trying to log in
	   (let* ((username (read-string "Who should we log in to lastpass as? "))
		  (process (start-process-shell-command 
			    "lastpass"
			    nil
			    (concat "LPASS_DISABLE_PINENTRY=1 lpass login "
				    (shell-quote-argument username)))))
	     (set-process-filter
	      process
	      ;; Respond to password and 2fa challenges
	      (lambda (proc string)
		(when (string-match-p (regexp-quote "Master Password") string)
		  (process-send-string proc
				       (concat (read-passwd "Lastpass Master Password? ") "\n")))
		(when (string-match-p (regexp-quote "Code") string)
		  (unless (string-match-p (regexp-quote "out-of-band") string)
		    (process-send-string proc
					 (concat (read-passwd "2FA Code? ") "\n"))))
		(when (string-match-p (regexp-quote "Success") string)
		  (message "Lastpass logged in")
		  (funcall continuation)))))))) ; This needs lexical binding

     (defun gds-lastpass-login ()
       "Ensure the lpass CLI is logged in.

     Check with `lpass status` if we're logged in. If not, log in."
       (interactive)
       (gds-lastpass-ensure-logged-in-and-then (lambda ())))

     (defun gds-lastpass-logout ()
       "Ensure the lpass CLI is logged out."
       (interactive)

       (shell-command "lpass logout -f")
       (message "Lastpass logged out"))
   #+END_SRC

** Slack

   It'd be great to use the [[https://github.com/yuya373/emacs-slack][slack package]] to connect to [[https://slack.com][slack]]. 

*** TODO Get slack creds into lastpass, and make that work

** Email

   I've historically liked [[http://gnus.org/][gnus]] for email, news, and RSS.

*** TODO See if gnus makes sense with my current gmail setup

*** TODO See if gnus can play nice with my lastpass setup
